<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0" name="viewport">
    <title>Blog Post</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
        }

        .column {
            flex: 1;
            padding: 20px;
            box-sizing: border-box;
        }

        .column:nth-child(2) {
            flex: 0 0 30%;
        }

        .container {
            display: flex;
            margin: auto;
            padding: 20px;
            background-color: #fff;
        }

        .ad {
            margin: 20px 0;
            text-align: center;
        }

        .ad img {
            max-width: 100%;
            height: auto;
            object-fit: contain;
        }

        li {
            margin: 5px 0;
        }
    </style>
    <script async id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

<div class="container">
    <div class="column">
        <h1 style="font-size: 50px; color: cornflowerblue">https://tcs-blog.sytes.net</h1>


        <h1>Private Set Intersection</h1>

        <h2>Problem definition</h2>

        <p>Alice has a set of elements \( A = (a_1, \dots, a_n) \) and Bob has a set of elements \( B = (b_1, \dots,
            b_m) \).
            They wish to learn \( A \cap B \), but are unwilling to share any elements that are not in the intersection
            with each other.</p>

        <iframe height="550" src="/static/blog/figures/psi_definition.svg" style="border:none;" width="650"></iframe>

        <p>Alice and Bob will use the help of a third party server, Steve. They do not trust him, so they will have to
            verify all of his claims.</p>

        <h2>The protocol</h2>

        <p>Alice has a set of strings \( A = (a_1, \dots, a_n) \), Bob has a set of strings \( B = (b_1, \dots, b_m) \).
            All parties agree to work
            over a field \( \mathbb{F} \) and on a pseudorandom function \( F : (str \times \mathbb{F}) \rightarrow
            \mathbb{F} \). The sizes of \( A \) and \( B \) are public.</p>

        <ol>
            <li>Alice and Bob agree on a secret key \( k \in \mathbb{F} \).</li>
            <li>Alice calculates \( A' = (a_1', \dots, a_n') \), where \( a_i' = F(a_i, k) \) and sends it to Steve.
            </li>
            <li>Bob calculates \( B' = (b_1', \dots, b_m') \), where \( b_i' = F(b_i, k) \) and sends it to Steve.</li>
            <li>Steve computes \( Z = A' \cap B' \) and sends it to Alice and Bob.</li>
            <li>Alice verifies that all elements with hashes in \( Z \) are in fact in \( A \).</li>
            <li>Bob verifies that all elements with hashes in \( Z \) are in fact in \( B \).</li>
            <li>Alice chooses a random polynomial \( P \) over \( \mathbb{F} \) of degree \( |A| + |B| - |Z| - 1 \) and
                sends it to Bob.
            </li>
            <li>Alice calculates \( A^P = ((a_1', P(a_1')), \dots, (a_n', P(a_n'))) \) and sends it to Steve.</li>
            <li>Bob calculates \( B^P = ((b_1', P(b_1')), \dots, (b_m', P(b_m'))) \) and sends it to Steve.</li>
            <li>Steve interpolates \( P \) from points \( A^P \cup B^P \) and sends \( P(0_{\mathbb{F}}) \) to Alice and
                Bob.
            </li>
            <li>Alice verifies that the value sent by Steve is in fact \( P(0_{\mathbb{F}}) \).</li>
            <li>Bob verifies that the value sent by Steve is in fact \( P(0_{\mathbb{F}}) \).</li>
        </ol>

        <p>Steps 7. to 12. are necessary to make sure that Steve did not omit any elements from the intersection.
            If there are in fact only \( |Z| \) elements in the intersection, then there are \( |A| + |B| - |Z|\)
            distinct elements in total, and Steve will be able to interpolate \( P \).</p>

        <h2>Example usages</h2>

        <ul>
            <li><b>Measuring ad efficiency (our use-case)</b>:
                A car company wants to know which of their clients have at any point clicked an ad the company paid for.
                The ad-providing company keeps a list of all registered accounts that clicked on ads.
                PSI allows them to calculate the intersection of those sets of accounts.
            </li>
            <li><b>DNA matching</b>:
                A client wishes to check whether their DNA sequence is related to any diseases.
                A research facility that stores a list of suspicious sequences wants to keep it private.
                PSI allows the client to make a query without revealing their entire DNA sequence.
            </li>
            <li><b>Password checkup</b>:
                A client has a list of passwords they use, and the server stores a list of leaked passwords.
                PSI allows the client to know which passwords are leaked while keeping the rest of them secure.
            </li>
            <li><b>Dating preferences</b>:
                Alice and Bob have a set of their dating preferences.
                PSI allows them to know what they both expect while keeping the rest of their taste private.
            </li>
        </ul>

        <!--        <h2>Our use-case</h2>-->

        <!--        <p>In our case, Alice is the ad-providing company, and Bob is a cars' dealership. Both parties keep a list of-->
        <!--            registered users-->
        <!--            and thanks to the PSI, they can check how effective the ads were.</p>-->

    </div>
    <div class="column">
        <div class="ad" id="ad1"></div>

        <div class="ad" id="ad2"></div>

        <div class="ad" id="ad3"></div>
    </div>
</div>

<script src="/static/blog/utils.js"></script>
</body>
</html>
